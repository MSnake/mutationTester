1. Алгоритм мутации удаления строк:
	1. Строка и исходным кодом разбивается на массив строк
	2. Создается пустой массив - новый массив строк(массив строк мутанта)
	3. Проходимся по массиву строк из п.1: 
		если номер строки не содержится в списке строк для удаления, то строка добавляется в новый массив строк п.2, иначе игнорируется.
	4. Сформированный массив строк после мутации п.2 преобразуется в строку путем склеивания строк исходного кода после мутации
	
2. Алгоритм мутации замены символов:
	1. Из исходного кода удаляются все коментатрии, вместо них вставляется пусой символ(""), 
		а так же добавляется перенос на новую строку если нужно - это сделано для сохранения исходного общего количества строк
	2. Строка из п.1 разбивается на массив строк
	3. Создается пустой массив - новый массив строк(массив строк мутанта)
	4. Создается карта какие символы на какие нужно заменить
	5. Для каждого элмента из массиова сформированного в п.2:
		1. Создаются массив с дубликатами строки с замененными символами. Количество дубликатов = количеству замен в карте п.3. 
			Т.е. в каждом новом дубликате применяется одна из замен карты.
		2. На основе массива с дубликатами п.4.1 формируется новая строка исходного кода с замененными символами(мутант строки):
			1. По символьно для каждого элемента массива п.4.1 происходит сравнение с "эталонным" символом исходной строки.
			2. Если найден символ отличающийся от "эталонного" в финальную формируемую строку(мутантную) будет записан именно он,
				если для определенного символа все элементы массива п.4.1 будут соответственно равны, то в финальную формируемую
				строку(мутантную) будет записан "эталонный" символ
		3. Сформированная строка в п.4.2 Добавляется в финальный массив строк мутанта п.3
	5. Сформированный массив строк после мутации п.3 преобразуется с строку путем склеивания - строка исходного кода после мутации
	
3. Алгоритм мутации отрицания условных операторов:
	1. Строка с исходным кодом разбивается на массив строк
	2. Создается пустой массив - новый массив строк(массив строк мутанта)
	3. В каждом элементе из массива п.1. производится поиск по выражению "if" без учета регистра.
	4. Если строка элмента массива п.1 удовлетворила условию в п.2(была найдена строка с оператором if) то:
		1. Производится проверка на то, что все логическое условие записано в этой строке ->
			количество открывающихся скобок("(") == количеству закрываюзихся скобок(")")
		2. Если проверка п.4.1. прошла успешно:
			1. Перед первой скобкой добавляютя символы "(!", а после последней закрыващейся скобки добавляется символ ")
			2. Строка разбивается на массив строк по выражению переноса на следующую строку
			3. Массив строк п.4.2.2 добавляется в массив строк мунтанта п.2
		3. Если проверка п.3.1. прошла неудачно:
			1. Исходный массив строк модифицируется путем склеивания со строкой следующего элемента массива п.1
			3. Возвращаемя к п.4.1
		иначе строка без изменений добавляется в массив строк мунтанта п.2
	5. Сформированный массив строк после мутации п.2 преобразуется с строку путем склеивания - строка исходного кода после мутации
	
4. Алгоритм сохранения мутационного теста:
	1. Вычисляется хэш сумма строки с исходным кодом для тестирования
	2. В БД ищется запись об исходном коде хэш сумма которого совпадает с хэш суммой п.1
	3. Если запись не была найдена формируется новая запись в БД
		1. Сохраняется информация о исходном коде
		2. Сохраняется информация о коде тестирования
		3. Производится мутация
		4. Сохраняется информация о мутации
	4. Если запись была найдена:
		1. Вычисляется хэш сумма кода тестирования.
		2. В БД ищется запись о коде тестирования хэш сумма которого совпадает с хэш суммой п.4.1, а так же принадлежащая к записи БД исходного кода
		3. Если запись не была найдена формируется новая запись в БД
		4. Если запись была найдена используется информация из БД
		5. Производится мутация исходного кода согласно установленным настройкам мутации
		6. Вычисляется хэш сумма мутированного кода
		7. В БД ищется запись о мутированном коде хэш сумма которого совпадает с хэш суммой п.4.6, а так же принадлежащая к записи БД исходного кода
		8. Если запись не была найдена формируется новая запись в БД
		9. Если запись была найдена используется информация из БД
	5. Исходя из найденных или созданных записях о коде тестирования и мутациях формируется запись о результатах тестирования со статусом "NOT_RUNNING"

4. Алгоритм запуска мутационного теста:
	1. Производится сохранение данных согласно алгоритму сохранения мутационного теста
	2. Исходя из записи о результатах тестирования со статусом "NOT_RUNNING" в жизнном цикле приложения происходит компиляция в одном и том же пакете:
		1. Мутационного кода 
		2. Кода тестирования
	3. Статус теста переводится в "PROCESSED" и сохраняется в БД
	4. Запускается скомпилированный класс кода тестирования
	5. По результатм тестирования поставляется статус для данного теста в БД
	6. Вывод результатов в консоль с информацией о тестировании
	
